= 4 Running Programs Under gdb

* When you run a program under gdb, you must first generate debugging
  information when you compile it.

'''

* You may start gdb with its arguments, if any, in an environment of your
  choice.
* If you are doing native debugging, you may redirect your program's input and
  output, debug an already running process, or kill a child process.

== 4.1 Compiling for Debugging

* In order to debug a program effectively, you need to generate debugging
  information when you compile it.
* This debugging information is stored in the object file; it describes the
  data type of each variable or function and the correspondence between source
  line numbers and addresses in the executable code.

'''

* To request debugging information, specify the \'``-g``' option when you run
  the compiler.

'''

* Programs that are to be shipped to your customers are compiled with
  optimizations, using the \'``-O``' compiler option.
* However, some compilers are unable to handle the \'``-g``' and \'``-O``'
  options together.
* Using those compilers, you cannot generate optimized executables containing
  debugging information.

'''

* gcc, the gnu C/C++ compiler, supports \'``-g``' with or without \'``-O``',
  making it possible to debug optimized code.
* We recommend that you always use \'``-g``' whenever you compile a program.
* You may think your program is correct, but there is no sense in pushing your luck.
* For more information, see Chapter 11 [Optimized Code], page 195.

'''

* Older versions of the gnu C compiler permitted a variant option \'``-gg``'
  for debugging information.
* gdb no longer supports this format; if your gnu C compiler has this option,
  do not use it.

'''

* gdb knows about preprocessor macros and can show you their expansion (see
  Chapter 12 [Macros], page 199).
* Most compilers do not include information about preprocessor macros in the
  debugging information if you specify the `-g` flag alone.
* Version 3.1 and later of gcc, the gnu C compiler, provides macro information
  if you are using the DWARF debugging format, and specify the option `-g3`.

'''

* See Section "Options for Debugging Your Program or GCC" in Using the gnu
  Compiler Collection (GCC), for more information on gcc options affecting
  debug information.

'''

* You will have the best debugging experience if you use the latest version of
  the DWARF debugging format that your compiler supports.
* DWARF is currently the most expressive and best supported debugging format
  in gdb.

== 4.2 Starting your Program

`run`::
`r`::
* Use the `run` command to start your program under gdb.
* You must first specify the program name with an argument to gdb (see Chapter
  2 [Getting In and Out of gdb], page 11), or by using the i`file` or
  `exec-file` command (see Section 18.1 [Commands to Specify Files], page
  291).

'''

* If you are running your program in an execution environment that supports
  processes, `run` creates an inferior process and makes that process run your
  program.
* In some environments without processes, `run` jumps to the start of your
  program.
* Other targets, like \'``remote``', are always running.
* If you get an error message like this one:
+
....
The "remote" target does not support "run".
Try "help target" or "continue".
....
+
then use `continue` to run your program.
* You may need `load` first (see [load], page 313).

'''

* The execution of a program is affected by certain information it receives
  from its superior.
* gdb provides ways to specify this information, which you must do before
  starting your program.
* (You can change it after starting your program, but such changes only affect
  your program the next time you start it.)
* This information may be divided into four categories:

'''

The _arguments_.::
* Specify the arguments to give your program as the arguments of the `run`
  command.
* If a shell is available on your target, the shell is used to pass the
  arguments, so that you may use normal conventions (such as wildcard
  expansion or variable substitution) in describing the arguments.
* In Unix systems, you can control which shell is used with the `SHELL`
  environment variable.
* If you do not define `SHELL`, gdb uses the default shell (`/bin/sh`).
* You can disable use of any shell with the `set startup-with-shell` command
  (see below for details).

The _environment_.::
* Your program normally inherits its environment from gdb, but you can use the
  gdb commands `set environment` and `unset environment` to change parts of
  the environment that affect your program.
* See Section 4.4 [Your Program's Environment], page 38.

The _working directory_.::
* You can set your program's working directory with the command `set cwd`.
* If you do not set any working directory with this command, your program will
  inherit gdb's working directory if native debugging, or the remote server's
  working directory if remote debugging.
* See Section 4.5 [Your Program's Working Directory], page 39.

The _standard input and output_.::
* Your program normally uses the same device for standard input and standard
  output as gdb is using.
* You can redirect input and output in the `run` command line, or you can use
  the `tty` command to set a different device for your program.
* See Section 4.6 [Your Program's Input and Output], page 40.
+
[WARNING]
====
* While input and output redirection work, you cannot use pipes to pass the
  output of the program you are debugging to another program; if you attempt
  this, gdb is likely to wind up debugging the wrong program.
====

* When you issue the `run` command, your program begins to execute
  immediately.
* See Chapter 5 [Stopping and Continuing], page 57, for discussion of how to
  arrange for your program to stop.
* Once your program has stopped, you may call functions in your program, using
  the `print` or `call` commands.
* See Chapter 10 [Examining Data], page 141.

'''

* If the modification time of your symbol file has changed since the last time
  gdb read its symbols, gdb discards its symbol table, and reads it again.
* When it does this, gdb tries to retain your current breakpoints.

== 4.12 Setting a Bookmark to Return to Later

* On certain operating systems{empty}footnote:[Currently, only gnu/Linux.],
  gdb is able to save a snapshot of a program's state, called a _checkpoint_,
  and come back to it later.

'''

* Returning to a checkpoint effectively undoes everything that has happened in
  the program since the checkpoint was saved.
* This includes changes in memory, registers, and even (within some limits)
  system state.
* Effectively, it is like going back in time to the moment when the checkpoint
  was saved.

'''

* Thus, if you're stepping through a program and you think you're getting
  close to the point where things go wrong, you can save a checkpoint.
* Then, if you accidentally go too far and miss the critical statement,
  instead of having to restart your program from the beginning, you can just
  go back to the checkpoint and start again from there.

* This can be especially useful if it takes a lot of time or steps to reach
  the point where you think the bug occurs.

'''

* To use the `checkpoint/restart` method of debugging:

'''

`checkpoint`::
* Save a snapshot of the debugged program's current execution state.
* The `checkpoint` command takes no arguments, but each checkpoint is assigned
  a small integer id, similar to a breakpoint id.

`info checkpoints`::
* List the checkpoints that have been saved in the current debugging session.
* For each checkpoint, the following information will be listed:
+
....
Checkpoint ID
Process ID
Code Address
Source line, or label
....

`restart _checkpoint-id_`::
* Restore the program state that was saved as checkpoint number
  _checkpoint-id_.
* All program variables, registers, stack frames etc. will be returned to the
  values that they had when the checkpoint was saved.
* In essence, gdb will "wind back the clock" to the point in time when the
  checkpoint was saved.
+
'''
* Note that breakpoints, gdb variables, command history etc. are not affected
  by restoring a checkpoint.
* In general, a checkpoint only restores things that reside in the program
  being debugged, not in the debugger.

`delete checkpoint _checkpoint-id_`
* Delete the previously-saved checkpoint identified by _checkpoint-id_.

'''

* Returning to a previously saved checkpoint will restore the user state of
  the program being debugged, plus a significant subset of the system (OS)
  state, including file pointers.
* It won't "un-write" data from a file, but it will rewind the file pointer to
  the previous location, so that the previously written data can be
  overwritten.
* For files opened in read mode, the pointer will also be restored so that the
  previously read data can be read again.

'''

* Of course, characters that have been sent to a printer (or other external
  device) cannot be "snatched back", and characters received from eg. a serial
  device can be removed from internal program buffers, but they cannot be
  "pushed back" into the serial pipeline, ready to be received again.
* Similarly, the actual contents of files that have been changed cannot be
  restored (at this time).

'''

* However, within those constraints, you actually can "rewind" your program to
  a previously saved point in time, and begin debugging it again -- and you can
  change the course of events so as to debug a different execution path this
  time.

'''

* Finally, there is one bit of internal program state that will be different
  when you return to a checkpoint -- the program's process id.
* Each checkpoint will have a unique process id (or _pid_), and each will be
  different from the program's original _pid_.
* If your program has saved a local copy of its process id, this could
  potentially pose a problem.

=== 4.12.1 A Non-obvious Benefit of Using Checkpoints

* On some systems such as gnu/Linux, address space randomization is performed
  on new processes for security reasons.
* This makes it difficult or impossible to set a breakpoint, or watchpoint, on
  an absolute address if you have to restart the program, since the absolute
  location of a symbol will change from one execution to the next.

'''

* A checkpoint, however, is an identical copy of a process.
* Therefore if you create a checkpoint at (eg.) the start of main, and simply
  return to that checkpoint instead of restarting the process, you can avoid
  the effects of address randomization and your symbols will all stay in the
  same place.
