= 5 Stopping and Continuing
:toc: left

* The principal purposes of using a debugger are so that you can stop your
  program before it terminates; or so that, if your program runs into trouble,
  you can investigate and find out why.

'''

* Inside gdb, your program may stop for any of several reasons, such as a
  signal, a breakpoint, or reaching a new line after a gdb command such as
  `step`.
* You may then examine and change variables, set new breakpoints or remove old
  ones, and then continue execution.
* Usually, the messages shown by gdb provide ample explanation of the status
  of your program -- but you can also explicitly request this information at
  any time.

'''

`info program`::
* Display information about the status of your program: whether it is running
  or not, what process it is, and why it stopped.

== 5.1 Breakpoints, Watchpoints, and Catchpoints

* A _breakpoint_ makes your program stop whenever a certain point in the
  program is reached.
* For each breakpoint, you can add conditions to control in finer detail
  whether your program stops.
* You can set breakpoints with the `break` command and its variants (see
  Section 5.1.1 [Setting Breakpoints], page 58), to specify the place where
  your program should stop by line number, function name or exact address in
  the program.

'''

* On some systems, you can set breakpoints in shared libraries before the
  executable is run.

'''

* A _watchpoint_ is a special breakpoint that stops your program when the
  value of an expression changes.
* The expression may be a value of a variable, or it could involve values of
  one or more variables combined by operators, such as \'``a + b``'.
* This is sometimes called _data breakpoints_.
* You must use a different command to set watchpoints (see Section 5.1.2
  [Setting Watchpoints], page 66), but aside from that, you can manage a
  watchpoint like any other breakpoint: you enable, disable, and delete both
  breakpoints and watchpoints using the same commands.

'''

* You can arrange to have values from your program displayed automatically
  whenever gdb stops at a breakpoint.
* See Section 10.8 [Automatic Display], page 155.

'''

* A _catchpoint_ is another special breakpoint that stops your program when a
  certain kind of event occurs, such as the throwing of a C++ exception or the
  loading of a library.
* As with watchpoints, you use a different command to set a catchpoint (see
  Section 5.1.3 [Setting Catchpoints], page 69), but aside from that, you can
  manage a catchpoint like any other breakpoint.
* (To stop when your program receives a signal, use the `handle` command; see
  Section 5.4 [Signals], page 89.)

'''

* gdb assigns a number to each breakpoint, watchpoint, or catchpoint when you
  create it; these numbers are successive integers starting with one.
* In many of the commands for controlling various features of breakpoints you
  use the breakpoint number to say which breakpoint you want to change.
* Each breakpoint may be enabled or disabled; if disabled, it has no effect on
  your program until you enable it again.

'''

* Some gdb commands accept a space-separated list of breakpoints on which to
  operate.
* A list element can be either a single breakpoint number, like \'``5``', or a
  range of such numbers, like \'``5-7``'.
* When a breakpoint list is given to a command, all breakpoints in that list
  are operated on.

=== 5.1.1 Setting Breakpoints

* Breakpoints are set with the `break` command (abbreviated `b`).
* The debugger convenience variable \'``$bpnum``' records the number of the
  breakpoint you've set most recently:

....
(gdb) b main
Breakpoint 1 at 0x11c6: file zeoes.c, line 24.
(gdb) p $bpnum
$1 = 1
....

* A breakpoint may be mapped to multiple code locations for example with
  inlined functions, Ada generics, C++ templates or overloaded function names.
* gdb then indicates the number of code locations in the breakpoint command
  output:

....
(gdb) b some_func
Breakpoint 2 at 0x1179: some_func. (3 locations)
(gdb) p $bpnum
$2 = 2
(gdb)
....

* When your program stops on a breakpoint, the convenience variables
  \'``$_hit_bpnum``' and \'``$_hit_locno``' are respectively set to the number
  of the encountered breakpoint and the number of the breakpoint's code
  location:

....
Thread 1 "zeoes" hit Breakpoint 2.1, some_func () at zeoes.c:8
8 printf("some func\n");
(gdb) p $_hit_bpnum
$5 = 2
(gdb) p $_hit_locno
$6 = 1
(gdb)
....

* Note that \'``$_hit_bpnum``' and \'``$bpnum``' are not equivalent:
  \'``$_hit_bpnum``' is set to the breakpoint number last hit, while
  \'``$bpnum``' is set to the breakpoint number last set.
* If the encountered breakpoint has only one code location, \'``$_hit_locno``'
  is set to 1:

....
Breakpoint 1, main (argc=1, argv=0x7fffffffe018) at zeoes.c:24
24 if (argc > 1)
(gdb) p $_hit_bpnum
$3 = 1
(gdb) p $_hit_locno
$4 = 1
(gdb)
....

* The \'``$_hit_bpnum``' and \'``$_hit_locno``' variables can typically be
  used in a breakpoint command list.
* (see Section 5.1.7 [Breakpoint Command Lists], page 77).
* For example, as part of the breakpoint command list, you can disable
  completely the encountered breakpoint using `_disable $_hit_bpnum_` or
  disable the specific encountered breakpoint location using `_disable
  $_hit_bpnum.$_hit_locno_`.
* If a breakpoint has only one location, \'``$_hit_locno``' is set to 1 and
  the commands `_disable $_hit_bpnum_` and disable `$_hit_bpnum.$_hit_locno`
  both disable the breakpoint.

'''

* You can also define aliases to easily disable the last hit location or last
  hit breakpoint:

....
(gdb) alias lld = disable $_hit_bpnum.$_hit_locno
(gdb) alias lbd = disable $_hit_bpnum
....
